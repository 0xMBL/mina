open Core

module Compose = struct
  module StringMap = Map.Make (String)

  module Network = struct
    type config = { driver : string } [@@deriving to_yojson]

    type t = { minaOverlay : config } [@@deriving to_yojson]

    let default = { minaOverlay = { driver = "overlay" } }
  end

  module Service = struct
    module Volume = struct
      type t =
        { type_ : string [@key "type"]; source : string; target : string }
      [@@deriving to_yojson]

      let create source target = { type_ = "bind"; source; target }
    end

    module Environment = struct
      type t = string StringMap.t

      let create = StringMap.of_alist_exn

      let to_yojson m =
        `Assoc (m |> Map.map ~f:(fun x -> `String x) |> Map.to_alist)
    end

    module Network = struct
      type t = string list

      let default = [ "minaOverlay" ]
    end

    module Dns = struct
      type t = string list [@@deriving to_yojson]

      let default = [ "8.8.8.8" ]
    end

    type t =
      { image : string
      ; command : string list
      ; entrypoint : string list option
            [@to_yojson
              fun j ->
                match j with
                | Some v ->
                    `List (List.map (fun s -> `String s) v)
                | None ->
                    `Null]
      ; ports : string list
      ; environment : Environment.t
      ; volumes : Volume.t list
      ; networks : Network.t
      ; dns : Dns.t
      }

    let to_yojson
        { image
        ; command
        ; entrypoint
        ; ports
        ; environment
        ; volumes
        ; networks
        ; dns
        } =
      `Assoc
        ( [ ("image", `String image)
          ; ("command", `List (List.map ~f:(fun s -> `String s) command))
          ; ("ports", `List (List.map ~f:(fun s -> `String s) ports))
          ; ("environment", Environment.to_yojson environment)
          ; ("volumes", `List (List.map ~f:Volume.to_yojson volumes))
          ; ("networks", `List (List.map ~f:(fun s -> `String s) networks))
          ; ("dns", `List (List.map ~f:(fun s -> `String s) dns))
          ]
        @
        match entrypoint with
        | Some ep ->
            [ ("entrypoint", `List (List.map ~f:(fun s -> `String s) ep)) ]
        | None ->
            [] )
  end

  let compose_file_name = "compose.json"

  let entrypoint_script =
    ( "entrypoint.sh"
    , {|#!/bin/bash
# This file is auto-generated by docker_compose.ml
# Generate keypair and set permissions
mina libp2p generate-keypair --privkey-path /root/libp2p-keys/key
/bin/chmod -R 700 /root/libp2p-keys/
# Execute the puppeteer script
exec /mina_daemon_puppeteer.py "$@"
|}
    )

  type service_map = Service.t StringMap.t

  let merge (m1 : service_map) (m2 : service_map) =
    Base.Map.merge_skewed m1 m2 ~combine:(fun ~key:_ left _ -> left)

  let service_map_to_yojson m =
    `Assoc (m |> Map.map ~f:Service.to_yojson |> Map.to_alist)

  let network_map_to_yojson m =
    `Assoc (m |> Map.map ~f:Network.to_yojson |> Map.to_alist)

  type t = { version : string; services : service_map; networks : Network.t }
  [@@deriving to_yojson]
end

type t = Compose.t [@@deriving to_yojson]

let to_string = Fn.compose Yojson.Safe.pretty_to_string to_yojson
