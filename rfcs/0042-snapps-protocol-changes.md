## Summary
[summary]: #summary

All the protcol changes required to support snapps

## Motivation

[motivation]: #motivation

To enable exciting new applications on Mina!

## Detailed design

[detailed-design]: #detailed-design

This document is based on the new transaction model proposed for enabling snapps [here](https://github.com/MinaProtocol/mina/pull/8068/files#diff-c072eceab70c51ee4dda6314d606f018176014fa7fef4c384f46ba74d7521035) and more proposals for supporting new features that are supported in other smart contract langugages are described [here](https://github.com/MinaProtocol/mina/blob/f0ad49658d62da50ca5c16f6780fd2871b254aba/rfcs/solidity-snapps.md). All the snapp features that we'd like to see are summarized [here](https://github.com/mrmr1993/coda/blob/rfc/snapp-features-spec/rfcs/snapp-features-spec.md)

#### Transaction Application

Proposed in the new transaction model is parties transactions where each pariticipant in the transaction is a separate `party` and a transaction is a list of parties. This is implemented in the two PRs [transaction application](https://github.com/MinaProtocol/mina/pull/9015) and [transaction snark](https://github.com/MinaProtocol/mina/pull/9016).
Payments and delegations remain as is and still follow the old transaction model.

The above PRs need the following changes

1. Move tokens to the new transaction model
2. Staged ledger tests with snapp transactions
3. Move Payments and delegations to the new model (Not required in the initial version)

The following changes to the transaction logic and/or transactions snark are from the proposals that are yet to be implemented

1. Add public input wirness as part of the transaction: This is for issuing transactions as part of a snapp transaction and modelling snapp execution as function evaluation.
2. Additional state in the transaction for a commitment to be stored in the account state.
3. Additional account state?
4. A new account field for token symbol
5. Snapp versioning

#### Transaction Pool

Verification of parties transactions is performed before adding them to the pool. This [PR](https://github.com/MinaProtocol/mina/pull/9219) is currently tracking the work for that.

TODO:

1. Generate snapp transactions for unit tests

2. Determine transaction priority: Transactions in the old model were ordered by fees. With the new model, transactions will have varied sizes and authorizations(verifying proofs / verifying signatures) and therefore varied computational costs.

#### Scan state

In the current transaction model, there are two transaction snarks- Base and Merge. A base snark prove that a transaction is valid and a merge snark proves that two base snarks or two merge snarks are valid.
In a [scan state](https://docs.minaprotocol.com/en/architecture/scan-state) tree, the leaves hold the data required to generate base proofs and the intermediate nodes hold the data required to generate merge proofs. A proof corresponding to the root of the tree proves all the transactions in the leaves of the tree

Snark work generated by a snark worker comprises of two proofs corresponding to two nodes on a tree.

With the new model, each party within a transaction forms the base transaction snark which are then merged recursively to produce a proof for the entire transaction. The proof then can be merged with proofs of other transactions similar to what is currently being done.

Given this, there are two ways to go about this in the scan state.

Proposal 1: A leaf will have `n` parties within a transaction and carries the resulting execution state from applying the previous parties. A snark worker then proves `2*n` parties and their merges per leaf, in total it'll generate `2n(n-1)+1` proofs (with the same binary tree implementation as scan state), instead of two proof per work in the current model. The circuit for parties are small and `n` can be determined by benchmarking the proving time.

For example, a scan state tree with four leafs and n = 2. `a1,a2,a3` represent parties of a transaction, `b1,b2,b3,b4` of another and so on.

                    (Merge)
          (Merge)           (Merge)
    (a1,a2)   (a3,b1)  (b2,b3)  (b4,_) 

A snark worker then computes the following:

      Merge
    a1    a2
and

      Merge
    a3    b1

Note: Payments, fee transfers, coinbase, and delegations are still in the old trnasaction model and so will have to be considered as 3, 1 or 2, 1 or 2, 3 parties respectively. 

Pros:

1. With fixed sized leafs, snark workers perform fixed amount of work per leaf.
2. The value `n` is configurable and can be increased based on prover performance
3. A fixed amount of work also means snark fees can be independent of the number of parties per transaction (This may be clearer after reading proposal 2). However, we may want to prorate the min transaction fees based on the number of parties so that bigger transactions pay higher fees

Cons:

1. Requires changes to the scan state
2. Execution state of a transaction would be duplicated in multiple leaves and therefore higher memory consumption.
3. Number of parties per transaction will be bounded by the scan state size
4. This makes the transaction selection logic a bit complex than it already is. Transactions will need to be selected based on what can "fit in" the slots given the zero fee-excess requirement for each tree i.e., all fees from transactions, paid to the proves, to the block producers should be settled. In the case a transactions in a block are in two trees, they should be settled separately with in their trees. However, this constraint can be removed by keeping track of the fee excess from each tree and adding it to the protocol state.

Proposal 2: Continue to have whole transactions in the leaves of a tree. Snark workers then have to prove the entire transaction.

Pros:

1. The scan state implementation won't change much
2. Number of parties per transaction is independent of the scan state
3. Transaction selection logic remains the same with no change to the zero fee-excess requirement
4. Execution state is not duplicated

Cons:

1. Two whole transactions will have to be proven by a single snark worker. We could change the snark work distribution such that only one proof is distributed per worker process and the snark coordinator does the job of bundling them. This will double the parallelization. However, a transaction can be arbitrarily long (although, restricted by the gossip network) and each snark worker will have to compute base snarks and merge snarks for all the parties in a transaction and therefore requires more resources for bigger transactions. The maximum number of parties per transaction will then be bounded by prover performance. It is not clear to me if this is better than being bounded by the scan state size. Some benchmarking exercises will probably make that clear.
2. Since bigger transactions are more expensive to prove, prover fees maybe higher and may not be payable by the new transactions included in blocks. This could increase the fees for smaller transactions as well for a while.

The advantage of proposal 2 is mainly faster implementation and decoupling snapp transaction size from the scan state. Snark worker performance could be worked on separately to improve proving time.

#### Snark worker

Irrepsective of which proposal is chosen to implement changes in the scan state, a snark worker needs to prove more than one party per leaf. Each snark worker proves multiple parties
and combine them to produce merge proofs similar to the scan state tree structure.

Optionally, change the snark work distribution such that each worker process gets only one of the `One_or_two.t`s and 

#### GraphQL

End points to serve new queries and mutations

1. Send a snapp transaction
2. Initialize a snapp account (Set verification keys, account state). This would be a specialized transaction since it might be a common use case to "deploy" the snapp before sending transactions
3. Show snapp transactions in transaction query results
4. Show snapp account state (modify any existing account queries)
5. Retrieve protocol state given a state hash or block height

Dependent on transaction and account type (yet to be finalized)

#### Archive Node

1. New tables to store snapp commands and any transaction-level data that is not stored on chain such as the public input for a proof
2. parties (without the proofs?)
3. A new table to store snapp account state per block
4. Expose a tool/command to generate intermediate snapp account states from the archive database within a block
5. Update replayer

Dependent on transaction and account type (yet to be finalized)

### Impacts

#### Gossip network

* Benchmarking current networking based on mainnet configurations (#9166, #9167)
* Define the transaction size limits

#### Snark worker

* Benchmark snark worker depending on how scan state is implemented

### Test plan

* Payments/delegations regressions
* Snapp transaction- unit tests, interation tests
* Tokens- unit tests, integration tests


## Unresolved questions
[unresolved-questions]: #unresolved-questions

1. Do we need to store snapp proofs in the archive database? This is similar to signatures which are not stored in the database.
